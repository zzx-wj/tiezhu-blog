(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{308:function(r,t,e){"use strict";e.r(t);var a=e(2),_=Object(a.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[r._v("#")]),r._v(" ES6")]),r._v(" "),t("p",[t("a",{attrs:{name:"Zxrzw"}})]),r._v(" "),t("h2",{attrs:{id:"_1let-和-const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1let-和-const"}},[r._v("#")]),r._v(" 1let 和 const")]),r._v(" "),t("p",[t("a",{attrs:{name:"jiV0y"}})]),r._v(" "),t("h3",{attrs:{id:"_1-1let"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1let"}},[r._v("#")]),r._v(" 1.1let")]),r._v(" "),t("ol",[t("li",[r._v("let 声明的变量，只在 let 命令所在的代码块内有效；特别之处：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域；")]),r._v(" "),t("li",[r._v("不存在变量提升(声明之前不能使用，必须要先声明，再使用。)；")]),r._v(" "),t("li",[r._v("暂时性死区（TDZ）：只要块级作用域内存在 let 命令，它声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（es6 明确规定：如果区块中存在 const let 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。在变量声明之前使用变量，就会报错）；总之 在代码快内，使用 let 声明变量之前，该变量都是不可用的，这就是暂时性死区。")]),r._v(" "),t("li",[r._v("不允许重复声明；")]),r._v(" "),t("li",[r._v("let 实际为 JavaScript 增加了块级作用域；\n"),t("a",{attrs:{name:"WSzzR"}})])]),r._v(" "),t("h3",{attrs:{id:"_1-2const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2const"}},[r._v("#")]),r._v(" 1.2const")]),r._v(" "),t("ol",[t("li",[r._v("声明一个只读的常量。一旦声明，常量的值就不能改变；")]),r._v(" "),t("li",[r._v("const 一旦声明，就必须立即初始化，不能留到以后再赋值；")]),r._v(" "),t("li",[r._v("作用域与 let 命令相同，只在声明所在的块级作用域内有效；")]),r._v(" "),t("li",[r._v("const 生命的变量同样不提升，同样存在暂时性死区")]),r._v(" "),t("li",[r._v("const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数字字符串布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复杂类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个实际数据的指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制，因此，将一个对象声明为常量必须十分小心。")])]),r._v(" "),t("p",[r._v("ES6 声明变量的 6 种方法:var let const function import class。\n"),t("a",{attrs:{name:"iDA3n"}})]),r._v(" "),t("h2",{attrs:{id:"_2-变量的结构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-变量的结构赋值"}},[r._v("#")]),r._v(" 2 变量的结构赋值")]),r._v(" "),t("p",[r._v("ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructing）"),t("br"),r._v("规则：只要右边的不是对象或数组，就先将其转为对象。"),t("br"),r._v("数组的解构赋值："),t("br"),r._v("如果解构不成功，变量的值就是 undefined；"),t("br"),r._v("允许指定默认值；"),t("br"),r._v("let [a, b, c] = [1, 2, 3]; let [, , third] = [1, 2, 3]//third=3 let [foo = true] = [];//foo=true"),t("br"),r._v("对象的解构赋值："),t("br"),r._v("变量名必须要与属性同名，才能取到正确的值；"),t("br"),r._v("也允许指定默认值；"),t("br"),r._v("let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\""),t("br"),r._v("字符串的解构赋值"),t("br"),r._v('const [a, b, c, d, e] = \'hello\'; a // "h" b // "e" c // "l" d // "l" e // "o"'),t("br"),r._v("数值和布尔值的解构赋值"),t("br"),r._v("let {toString: s} = 123; s === Number.prototype.toString // true let {toString: s} = true; s === Boolean.prototype.toString // true")]),r._v(" "),t("p",[t("a",{attrs:{name:"t4PJ2"}})]),r._v(" "),t("h2",{attrs:{id:"_3-字符串的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-字符串的扩展"}},[r._v("#")]),r._v(" 3 字符串的扩展")]),r._v(" "),t("p",[r._v("字符的 Unicode 表示法"),t("br"),r._v('允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。如："\\u0061"；'),t("br"),r._v('这种表示法只限于码点在\\u0000~\\uFFFF 之间的字符。超出这个范围 id 字符必须用两个双字节的形式表示。如："\\uD842\\uDFB7"；'),t("br"),r._v("字符串的遍历器接口"),t("br"),r._v("ES6 为字符串增加了遍历器接口，使得字符串可以被 for...of 循环遍历。"),t("br"),r._v("JSON.stringfy()的改造"),t("br"),r._v("模板字符串：使用`` （反引号）和${}"),t("br"),r._v("模板编译"),t("br"),r._v("标签模板"),t("br"),r._v("字符串的新增方法"),t("br"),r._v("String.fromCodePoint()"),t("br"),r._v("Sring.raw()"),t("br"),r._v("实例方法："),t("br"),r._v("codePointAt()"),t("br"),r._v("normalize()"),t("br"),r._v("includes() "),t("br"),r._v("startsWith()"),t("br"),r._v("endsWith()"),t("br"),r._v("repeat()"),t("br"),r._v("padStart()"),t("br"),r._v("padEnd()"),t("br"),r._v("trimStart()"),t("br"),r._v("trimEnd()"),t("br"),r._v("matchAll()"),t("br"),r._v("repeatAll()"),t("br"),r._v("at()\n"),t("a",{attrs:{name:"BZ8VO"}})]),r._v(" "),t("h2",{attrs:{id:"_4-正则的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-正则的扩展"}},[r._v("#")]),r._v(" 4 正则的扩展")]),r._v(" "),t("p",[t("a",{attrs:{name:"OxT1y"}})]),r._v(" "),t("h2",{attrs:{id:"_5-数值的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-数值的扩展"}},[r._v("#")]),r._v(" 5 数值的扩展")]),r._v(" "),t("p",[r._v("二进制和八进制表示法："),t("br"),r._v("二进制：0B(或者 0b)"),t("br"),r._v("八进制：0O（或者 0o）"),t("br"),r._v("十六进制：0X（或者 0x）"),t("br"),r._v("数值分隔符：欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如：1000 可以写作 1,000；"),t("br"),r._v("ES2021，允许 JavaAScript 的数值使用下划线_作为分隔符。这个数值分割符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位，每两位，每四位添加一个。"),t("br"),r._v("小数和科学技术法也可以使用数值分隔符。"),t("br"),r._v("使用要求：不能放在数值的最前面或最后面；不能两个或两个以上的分隔符连在一起；小数点的前后不能有分隔符；科学计数法里，表示指数的 e 或者 E 前后不能有分隔符。"),t("br"),r._v("分隔符不能紧着这进制的前缀；"),t("br"),r._v("Number 和 parseInt 和 parserFloat 方法不支持数值分隔符。"),t("br"),r._v("提供了新的方法："),t("br"),r._v("Numer.inFinite()"),t("br"),r._v("Number.isNaN()"),t("br"),r._v("Number.parseInt()//从 window 对象移植到 Number 对象上"),t("br"),r._v("Numbet.parseFloat()//从 window 对象移植到 Number 对象上"),t("br"),r._v("Number.isInteger()"),t("br"),r._v("Number.EPSILON()常量：表示 1 与大于 1 的最小浮点数之间的差；"),t("br"),r._v("Number.isSageInteger()"),t("br"),r._v("Math 对象的扩展：新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。\n"),t("a",{attrs:{name:"j5vAE"}})]),r._v(" "),t("h2",{attrs:{id:"_6-函数的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-函数的扩展"}},[r._v("#")]),r._v(" 6 函数的扩展")]),r._v(" "),t("p",[r._v("函数参数的默认值"),t("br"),r._v("且可以与解构赋值结合使用；"),t("br"),r._v("通常情况下，定义了默认值的参数，应该是函数的尾参数。"),t("br"),r._v("指定参数默认值，函数的 length 属性会失真；"),t("br"),r._v("一旦设置了参数的默认值，函数进行生命初始化时，参数会形成一个单独的作用域（context）。等到初始化结束时，这个作用域会消失。"),t("br"),r._v("rest 参数：用于获取函数的多余参数，这样就不需要使用 arguments 对象。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。"),t("br"),r._v("函数的 length 属性，不包括 rest 参数；"),t("br"),r._v("严格模式"),t("br"),r._v("函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部不能显式设定为严格模式，否则会报错；"),t("br"),r._v("name 属性：返回该函数的函数名字；"),t("br"),r._v("箭头函数：允许使用=>定义函数；"),t("br"),r._v("箭头函数没有自己的 this 对象；"),t("br"),r._v("不可以当作构造函数，也就是不可以对箭头函数使用 new 命令，否则抛出错误；"),t("br"),r._v("不可以使用 atguments 对象，该对象在函数体内不存在。如果要用，可以使用 rest 参数替代；"),t("br"),r._v("不可以使用 yield 命令，因此箭头函数不能够用作 Generator 函数；"),t("br"),r._v("尾调用优化"),t("br"),r._v("什么是尾调用（Tail Call）：某个函数的最后一部是调用另一个函数。"),t("br"),r._v("尾调用优化：函数调用会在内存形成一个”调用记录“，又叫”调用帧“（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还调用函数 C，那么就还有一个 C 的调用帧，以此类推。所有的调用帧，就形成了一个调用栈（call stack）。"),t("br"),r._v("尾调用是属于函数的最后一部操作，所以不需要再保留外层函数的调用帧，因为 i 调用位置，内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。"),t("br"),r._v("尾调用优化（Tail call optimization）：即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，浙江大大节省内存，这就是其意义。（注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数，否则无法进行尾调用优化。）"),t("br"),r._v("尾递归：函数调用自身，称为递归。如果尾调用自身，就成为尾递归。"),t("br"),r._v("递归非常消耗内存，因为需要同时保存成百上千个调用帧，很容易发生”栈溢出“错误（stack overflow）。但对于尾递归来说，由于只存在一个调用栈，所以永远不会发生”栈溢出“错误"),t("br"),r._v("function factorial(n) { if (n === 1) return 1; return n _ factorial(n - 1); } factorial(5) // 120 优化前：复杂都 O（n） //优化 尾递归 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n _ total); } factorial(5, 1) // 120 优化后：复杂度 O（1）")]),r._v(" "),t("p",[r._v("计算 Fibonacci 数列， function Fibonacci (n) { if ( n <= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2); } Fibonacci(10) // 89 Fibonacci(100) // 超时 Fibonacci(500) // 超时 使用尾递归优化： function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n <= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2); } Fibonacci2(100) // 573147844013817200000 Fibonacci2(1000) // 7.0330367711422765e+208 Fibonacci2(10000) // Infinity"),t("br"),r._v("由此可见：”尾调用优化“对于递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化“。这就是说，ES6 中只要使用了尾递归，就不会噶生栈溢出（或者层层递归造成的超时），相对节省内存。"),t("br"),r._v("尾递归的实现，往往需要改写递归函数，确保最后一部只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。"),t("br"),r._v("正常模式下，函数内部有两个变量，可以跟踪函数的调用栈，"),t("br"),r._v("func.arguments:返回调用时函数的参数"),t("br"),r._v("func.caller:返回调用当前函数的那个个函数；"),t("br"),r._v("尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真，严格模式禁用这两给变量，所以尾调用优化仅在严格模式下生效。"),t("br"),r._v("函数参数的尾逗号：ES2017 允许函数的最后一个参数有为尾逗号（tailing comma），此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。"),t("br"),r._v("Function.prototype.toString()"),t("br"),r._v("ES2019 对函数实例的 toString()方法做出了修改。"),t("br"),r._v("toString（）方法返回函数 diamagnetic 本身，以前会省略注释和空格。"),t("br"),r._v("catch 命令的参数省略"),t("br"),r._v("以前明确要求 catch 命令后面必须跟参数，接受 try 代码块抛出的错误对象。"),t("br"),r._v("ES2019 做出了改变，允许 catch 语句省略参数。\n"),t("a",{attrs:{name:"MVv4z"}})]),r._v(" "),t("h2",{attrs:{id:"_7-数组的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-数组的扩展"}},[r._v("#")]),r._v(" 7 数组的扩展")]),r._v(" "),t("p",[r._v("拓展运算符（spread）：是三个点（...）。它好比是 rest 参数的逆运算，将一个数组转为用逗号分割的参数序列。"),t("br"),r._v("console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5"),t("br"),r._v("该运算符主要用于函数调用；"),t("br"),r._v("后面还可以放置表达式；"),t("br"),r._v("替代函数的 apply（）方法；"),t("br"),r._v("复制数组；"),t("br"),r._v("合并数组；"),t("br"),r._v("与解构赋值结合；"),t("br"),r._v('将字符串转为数组；[..."sjhsksjss"]'),t("br"),r._v("实现了 Iterator 接口的对象；（任何定义了迭代器接口的对象，都可以使用扩展运算符转为真正的数组）"),t("br"),r._v("新增静态方法："),t("br"),r._v("Array.from()：将类似数组的对象（array-like object）和可遍历对象（iterable）的对象 转为真正的数组；"),t("br"),r._v("Array.of()：用于将一组值，转换为数组。主要目的是弥补 Array 构造函数的不足。"),t("br"),r._v("新增实例方法："),t("br"),r._v("copyWithin（）；"),t("br"),r._v("find（），findIndex（），findLast（），findLastIndex（）；"),t("br"),r._v("fill（）；"),t("br"),r._v("entries（），keys（），values（）；"),t("br"),r._v("includes（）；与字符串的 includes（）类似；"),t("br"),r._v("flat（），flatMap（）；"),t("br"),r._v("at（）；"),t("br"),r._v("toReversed（），roSorted（），toSliced（），with（）；"),t("br"),r._v("group（），groupToMap（）；"),t("br"),r._v("数组的空位："),t("br"),r._v("数组的空位指的是，数组的某一个位置没有任何值，比如 Array（）构造函数返回的数组都是空位。"),t("br"),r._v("空位不是 undefined，某一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点。"),t("br"),r._v("0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false"),t("br"),r._v("ES6 明确地将空位转为 undefined；"),t("br"),r._v("Array.prototype.sort()的排序稳定性："),t("br"),r._v("排序稳定性（stable sorting）是排序算法的重要属性，指的是关键字排序相同的项目，排序前后的顺序不变；"),t("br"),r._v("常见的算法中，插入排序，合并排序，冒泡排序等都是稳定的，堆排序，快读排序是不稳定的。不稳定排序的主要缺点是：多重排序可能会产生问题。"),t("br"),r._v("Array.prototype.sort()默认的排序算法必须是稳定的。且这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。")]),r._v(" "),t("p",[t("a",{attrs:{name:"T0xMI"}})]),r._v(" "),t("h2",{attrs:{id:"_8-对象的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-对象的扩展"}},[r._v("#")]),r._v(" 8 对象的扩展")]),r._v(" "),t("p",[r._v("属性的简介表示法："),t("br"),r._v("ES6 允许在大括号里面，直接写入变量和函数，作为属性的对象和方法。"),t("br"),r._v("除了属性简写，方法也可以简写；"),t("br"),r._v("属性名表达式"),t("br"),r._v("js 定义对象的属性，有两种方法：一：直接使用标识符作为属性名，二：使用表达式作为属性名，这是要将表达式方法方括号之内。"),t("br"),r._v("ES6 允许字面量定义对象时，用方法二作为对象的属性名，即吧表达式放在方括号内。"),t("br"),r._v("方法的 name 属性"),t("br"),r._v("函数的 name 属性返回函数名。对象方法也是函数，因此也有 name 属性。"),t("br"),r._v("如果对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是在该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加 get 和 set；"),t("br"),r._v("两种特殊情况：bind 方法创造的函数以及对象的方法是 Symbol 值。"),t("br"),r._v("属性的可枚举型和遍历"),t("br"),r._v("对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为，Object.getProtoTypeDescriptor 方法可以获取该属性的描述对象。"),t("br"),r._v("描述对象的 enumerable 属性，成为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。（fon...in ， Object.keys()，Json.stringfy()，Object.assign()会忽略 enumerable 属性为 false 的属性)；"),t("br"),r._v("enumerable 这个概念的最初目的，就是让某些属性规避掉 for...in 操作，不谈所有内部属性和方法都会被遍历到。比如：对象原型的 toString 方法，以及数组的 length 属性。就通过 enumerable 从而被 for...in 遍历到。"),t("br"),r._v("属性的遍历：ES6 一共有 5 中方法可以遍历对象的属性："),t("br"),r._v("for...in（循环遍历对象自身的和继承的可枚举属性，不包含 Symbol 属性）"),t("br"),r._v("Object.keys()返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名；"),t("br"),r._v("Object.getOwnPropertyNams()：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包含不可枚举属性）的键名；"),t("br"),r._v("Object.getOwnPropertySymbol()：返回一个数组，包含对象自身的所有 Symbol 属性的键名；"),t("br"),r._v("Reflect.ownKeys()：返回一个数组，包含对象自身（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。"),t("br"),r._v("以上的 5 种遍历对象的键名，都遵守同样的属性遍历的次序规则："),t("br"),r._v("--首先遍历所有数值键，按照数字升序排列；"),t("br"),r._v("--其次是遍历所有字符串键，按照加入时间升序排列；"),t("br"),r._v("--最后 i 案例所有 Symbol 键，按照加入时间升序排列。")]),r._v(" "),t("p",[r._v("super 关键字"),t("br"),r._v("this 关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。"),t("br"),r._v("super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方会报错。")]),r._v(" "),t("p",[r._v("对象的扩展运算符"),t("br"),r._v("解构赋值："),t("br"),r._v("对象的解构赋值用于从一个对象取值，相当于将目标对象的自身所有可枚举（enumerable）的，但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会被拷贝到新对象上面。"),t("br"),r._v("解构赋值要求等号右边是一个对象，所有如果等号右边是 undefined 或 null，就会报错，因为它们无法被转为对象。如果右边是基本类型的数据，会自动调用对应的包装类转为对象；"),t("br"),r._v("解构赋值必须是最后一个参数，否则会报错；"),t("br"),r._v("解构赋值的拷贝是浅拷贝，即如果一个键的值是引用（复杂）数据类型的值（数组队形函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本；"),t("br"),r._v("扩展运算符的解构赋值，不能复制继承原型对象的属性；"),t("br"),r._v("单纯的解构赋值，可以读取对象继承的属性；"),t("br"),r._v("扩展运算符"),t("br"),r._v("ES2018 将来这个扩展运算符引入到了对象。"),t("br"),r._v("对象的扩展运算符（...）用于取出参数对象的所有可枚举属性，拷贝到当前对象之中。"),t("br"),r._v("如果扩展运算符后不是对象，会自动进行包装；"),t("br"),r._v("对象的扩展运算符，指挥返回参数对象自身的，可枚举的属性；")]),r._v(" "),t("p",[r._v("AggregateError 对象"),t("br"),r._v("ES2021 标准之中，为了配合 Primise.any()方法，还引入了一个新的错误对象 AggregateError；"),t("br"),r._v("Error 对象的 cause 属性"),t("br"),r._v("Error 对象用来表示代码运行时的异常情况，但是从这个对象拿到的上下文信息，有时很难解读，也不够充分。ES2022 为 Error 对象添加了一个 cause 属性，可以在生成错误时，添加报错原因的描述。"),t("br"),r._v("对象的新增方法"),t("br"),r._v("Object.is()：比较两个值是否严格相等与“===”运算符的行为基本一致；（但是有两个不同的地方：【ES6 提出 “same-value equality” （同值相等）】"),t("br"),r._v("Object.is(NaN,NaN) // true Object.is(+0,-0) // false"),t("br"),r._v("Object.assign()：用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象上（target）。"),t("br"),r._v("--是浅拷贝；"),t("br"),r._v("--同名属性会替换，而不是添加；"),t("br"),r._v("--数组的处理：会被对象化处理；"),t("br"),r._v("--取值函数的处理；"),t("br"),r._v("Object.getOwnPrpopertyDescriptors()：【ES2017】，返回指定对象的所有自身属性（非继承属性）的描述对象。"),t("br"),t("strong",[r._v("proto")]),r._v("属性，Object.setPrototypeOf()，Object.getProtoTypeOf()；"),t("br"),r._v("Js 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。"),t("br"),t("strong",[r._v("proto")]),r._v("属性：用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器都部署了这个属性。该属性没有写入 ES6 的正文，而且写入了附录，原因是"),t("strong",[r._v("proto")]),r._v("前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，由于只是浏览器广泛支持，才被加入了 ES6。标准明确指出，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论是从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用 Object.setPrototypeOf()（写操作），Object.getPrototypeOf()（读操作），Object.create()（生成操作）代替。"),t("br"),r._v("实现上，"),t("strong",[r._v("prototype")]),r._v("调用的是 Object.prototype."),t("strong",[r._v("proto")]),r._v("；"),t("br"),r._v("Object.keys()：返回一个数组，成员是参数对象自身的所有可枚举属性的键名；"),t("br"),r._v("Object.values()：返回一个数组，成员是参数对象自身的所有可枚举属性的键值；"),t("br"),r._v("Object.entries()：返回一个数组，成员是参数对象自身的所有可枚举属性的键值对数组。"),t("br"),r._v("Object.fromEntries()：是 Object.entries()的逆操作，用于将一个键值对数组转换为对象；"),t("br"),r._v("特别适合将 Map 结构转为对象；"),t("br"),r._v("配合 URLSearchParams 对象，将查询字符串转为对象"),t("br"),r._v("Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))"),t("br"),r._v("Object.hasOwn()：Js 对象的属性分为两种：自身的属性和继承的属性，对象实例有一个 hasOwmProperty()方法，可以判断某个属性是否为原生属性。ES2022 在 Object 对象上新增了一个静态方法：Object.hasOwn()，也可以判断是否为自身的属性；"),t("br"),r._v("hasOwn 的一个好处：对于不继承 Object.prototype 对象不会报错，而 hasOwnPrototype()是会报错的。"),t("br"),r._v("const obj = Object.create(null); obj.hasOwnProperty('foo') // 报错 Object.hasOwn(obj, 'foo') // false")]),r._v(" "),t("p",[t("a",{attrs:{name:"BVNh3"}})]),r._v(" "),t("h2",{attrs:{id:"_9-运算符的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-运算符的扩展"}},[r._v("#")]),r._v(" 9 运算符的扩展")]),r._v(" "),t("p",[r._v("指数运算符（"),t("strong",[r._v("）"),t("br"),r._v("2 ** 2 // 4 2 ** 3 // 8"),t("br"),r._v("特点：右结合。2")]),r._v("3"),t("strong",[r._v("2===>>>512；"),t("br"),r._v("新的赋值运算符：")]),r._v("="),t("br"),r._v("let a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b _ b _ b;")]),r._v(" "),t("p",[r._v("链判断运算符（ES2020）："),t("br"),r._v("编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在；"),t("br"),r._v("?.运算符：直接在链式调用的时候判断，左边的对象是否为 null 或者 undefined。如果是，就不在往下运算，而是返回 undefined。"),t("br"),r._v("iterator.return?.()//?. 能够先判断对象上的 return 方法是否存在，存在才会执行；"),t("br"),r._v("链判断运算符有三种写法："),t("br"),r._v("obj?.prop // 对象属性是否存在 obj?.[expr] // 对象属性是否存在 同上 function?.(...arguments) // 函数或对象方法是否存在"),t("br"),r._v("注意事项："),t("br"),r._v("短路机制：本质上，?.运算符相当于一种短路机制，只要不满足条件，就不在往下执行。"),t("br"),r._v("括号的影响：如果属性连有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。（一般来说，使用?.运算符的场景，不应该使用圆括号）"),t("br"),r._v("报错场景："),t("br"),r._v("右侧不得为十进制数值。")]),r._v(" "),t("p",[r._v("Null 判断运算符"),t("br"),r._v("读取对象属性的时候，如果某个属性的值是 null 或 undefined，有时候需要为它们指定默认值，常见的做法是通过||运算符指定默认值。"),t("br"),r._v("const code= res.code || '0000'; const content= res.content || []; const message= res.message|| 'success'; // 但是 这样的写法是错的，因为左侧如果是 0 或 false 或者+0 -0 （除 null undefined 之外的须值） // 为此 ES2020 引入了一个新的 Null 判断运算符?? "),t("br"),r._v("??运算符的行为类似||；但是只有运算符左侧的值是 null 或 undefined 时，才会返回右侧的值；"),t("br"),r._v("??本质上是逻辑运算，它与另外两个逻辑运算符&&和||有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同，现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。")]),r._v(" "),t("p",[r._v("逻辑赋值运算符"),t("br"),r._v("ES2021 引入了 3 个新的逻辑赋值运算符（logical assignment operators），将逻辑运算符与赋值运算符进行结合。"),t("br"),r._v("或赋值运算符 ： "),t("br"),r._v("x ||= y 等价于：x || （x = y）；"),t("br"),r._v("与赋值运算符："),t("br"),r._v("x &&= y 等价于 x &&（ x = y）；"),t("br"),r._v("Null 赋值运算符"),t("br"),r._v("x ??= y 等价与 x ??（ x = y） ；"),t("br"),r._v("这 3 个运算符||= &&= ??=相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。"),t("br"),r._v("用途：为变量或属性设置默认值；\n"),t("a",{attrs:{name:"x5SUb"}})]),r._v(" "),t("h2",{attrs:{id:"_10symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10symbol"}},[r._v("#")]),r._v(" 10Symbol")]),r._v(" "),t("p",[r._v("ES6 引入了一种新的原始数据类型 Symbol，表示独立无二的值。它属于 js 语言的原生数据类型之一，其它数据类型是 undefined null 布尔值 字符串 数值 大整数（BigInt） 对象。"),t("br"),r._v("Symbol 值通过 Symbol 函数生成。且不能使用 new 命令。"),t("br"),r._v("symbol 值不能与其它类型的值进行运算。"),t("br"),r._v("Symbol 可以显式转为字符串和布尔值，但是不能转换为数值：String（Symbol()），Boolean（Symbol（））;"),t("br"),r._v("Symbol.prototype.description：创建 symbol 值时可以添加一个描述符；"),t("br"),r._v("可以用来消除魔术字符串。魔术字符串：在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。"),t("br"),r._v("遍历："),t("br"),r._v("Symbol 值作为属性名，遍历对象的时候，该属性不会出现在 for...in for...of 循环中，也不会被 Object.keys() Object.getOwnPropertyNames() JSON.stringfy()返回；但是它不是一个私有属性，有一个 Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。"),t("br"),r._v("Symbil.for() Symbol.keyFor()："),t("br"),r._v("有时候，需要复用 Symbol 值，Symbol.for(）可以做到这一点。"),t("br"),r._v("Symbol.for()和 Symbol()这两种方法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。【iframe 窗口生成的 symbol 值，可以在主页面得到】"),t("br"),r._v("Symbol.keyfor()返回一个已登记的 Symbol 类型值的 key。"),t("br"),r._v("应用于模块的 singleton 模式；"),t("br"),r._v("内置的 Symbol 值："),t("br"),r._v("ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。")]),r._v(" "),t("p",[t("a",{attrs:{name:"pfN8X"}})]),r._v(" "),t("h2",{attrs:{id:"_11set-和-map-数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11set-和-map-数据结构"}},[r._v("#")]),r._v(" 11Set 和 Map 数据结构")]),r._v(" "),t("p",[r._v("ES6 提供了新的数据结构 Set。它类似与数组，但是成员的值都是唯一的，没有重复的值。"),t("br"),r._v("Set 函数可以接受一个数组或者具有 iterator 接口的其它数据结构作为参数，用来初始化。"),t("br"),r._v("Set 的遍历顺序就是插入顺序；"),t("br"),r._v("Set 结构没有键名，只有键值（或者说键名和键值是同一个值）；"),t("br"),r._v("Set 实例的属性和方法："),t("br"),r._v("Set.prototype.constructor:构造函数，模式就是 Set 函数；"),t("br"),r._v("Set.prototype.size：返回 Set 实例的成员总数；"),t("br"),r._v("操作方法："),t("br"),r._v("Set.prototype.add（value）：添加某个值，返回 Set 结构本身；"),t("br"),r._v("Set.prototype.delete（value）:删除某个值，返回一个布尔值，表示删除是否成功；"),t("br"),r._v("Set.prototype.has（value）：返回一个布尔值，表示该值是否为 Set 的成员；"),t("br"),r._v("Set.prototype.clear（）:清除所有成员，没有返回值。"),t("br"),r._v("遍历方法"),t("br"),r._v("Set.prototype.keys（）：返回键名的遍历器；"),t("br"),r._v("Set.prototype.values（）：返回键值的遍历器；"),t("br"),r._v("Set.prototype.entries（）：返回键值对的遍历器；"),t("br"),r._v("Set.pprototype.forEach（）：使用回调函数遍历每个成员；"),t("br"),r._v("WeakSet 结构与 Set 结构类似，也是不重复的值的集合。但是，它与 Set 有两个区别。"),t("br"),r._v("首先，WeakSet 的成员只能是对象，而不能是其它类型的值；"),t("br"),r._v("其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其它对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还存在于 WeakSet 之中。"),t("br"),r._v("任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数；"),t("br"),r._v("三个方法：add(),delete(),has();"),t("br"),r._v("Map：Js 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能使用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似与对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说。Object 结构提提供了“字符串-值”的对应，Map 结构提供了“值-值”的对应，是一种更完善的 Hash 结构实现。"),t("br"),r._v("Map 可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。"),t("br"),r._v("实际上，不仅仅是数组，任何具有 Iterable 结口，且每个成员都是一个双元素的数组的数据结构，否可以当作 Map 构造函数的参数。这就是说，Set 和 Map 都可以用来生成新的 Map；"),t("br"),r._v("属性和操作方法："),t("br"),r._v("size 属性；"),t("br"),r._v("set（）方法"),t("br"),r._v("get（）方法；"),t("br"),r._v("has（）方法；"),t("br"),r._v("delete（）方法；"),t("br"),r._v("clear（）方法；"),t("br"),r._v("遍历方法："),t("br"),r._v("keys（）；"),t("br"),r._v("values（）；"),t("br"),r._v("entires（）；"),t("br"),r._v("forEach（）；"),t("br"),r._v("WeakMap：WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合；"),t("br"),r._v("WeakMap 和 Map 的区别有两点："),t("br"),r._v("首先 WeakMap 只接受对象作为键名（undefined 和 null 除外），不接受其他类型的值作为键名。"),t("br"),r._v("其次 WeakMap 的键名所指向的对象，不计入垃圾回收机制；"),t("br"),r._v("语法："),t("br"),r._v("没有遍历操作；"),t("br"),r._v("没有 size 属性；"),t("br"),r._v("只有 get（），set（），has（），delete（）方法；"),t("br"),r._v("用途：WeakMap 应用的典型场合就是 DOM 节点作为键名。"),t("br"),r._v("WeakRef："),t("br"),r._v("WeakSet 和 WeakMap 是基于弱引用的数据结构，ES2021 更进一步，提供了 WeakRef 回想，用于直接创建对象的弱引用。"),t("br"),r._v("WeakRef 的引用不会破坏原始对象被垃圾回收机制清除。"),t("br"),r._v("FinalizationRegistry："),t("br"),r._v("ES2021 引入了清理注册表功能：FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。")]),r._v(" "),t("p",[t("a",{attrs:{name:"F83qT"}})]),r._v(" "),t("h2",{attrs:{id:"_12proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12proxy"}},[r._v("#")]),r._v(" 12Proxy")]),r._v(" "),t("p",[r._v("Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。"),t("br"),r._v("Proxy 可以理解为，在目标对象之前架设一层“拦截器”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。")]),r._v(" "),t("p",[t("a",{attrs:{name:"G4Etl"}})]),r._v(" "),t("h2",{attrs:{id:"_13reflect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13reflect"}},[r._v("#")]),r._v(" 13Reflect")]),r._v(" "),t("p",[r._v("Reflect 对象和 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。")]),r._v(" "),t("p",[t("a",{attrs:{name:"tvH99"}})]),r._v(" "),t("h2",{attrs:{id:"_14promise-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14promise-对象"}},[r._v("#")]),r._v(" 14Promise 对象")]),r._v(" "),t("p",[t("a",{attrs:{name:"hc5io"}})]),r._v(" "),t("h2",{attrs:{id:"_15iterator-和-for-of-循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15iterator-和-for-of-循环"}},[r._v("#")]),r._v(" 15Iterator 和 for...of 循环")]),r._v(" "),t("p",[t("a",{attrs:{name:"ZlZ7G"}})]),r._v(" "),t("h2",{attrs:{id:"_16generator-函数的语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16generator-函数的语法"}},[r._v("#")]),r._v(" 16Generator 函数的语法")]),r._v(" "),t("p",[t("a",{attrs:{name:"NCnWa"}})]),r._v(" "),t("h2",{attrs:{id:"_17generator-函数的异步应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17generator-函数的异步应用"}},[r._v("#")]),r._v(" 17Generator 函数的异步应用")]),r._v(" "),t("p",[t("a",{attrs:{name:"l9hFb"}})]),r._v(" "),t("h2",{attrs:{id:"_18async-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18async-函数"}},[r._v("#")]),r._v(" 18async 函数")]),r._v(" "),t("p",[t("a",{attrs:{name:"GDJEK"}})]),r._v(" "),t("h2",{attrs:{id:"_19class-的基本语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19class-的基本语法"}},[r._v("#")]),r._v(" 19Class 的基本语法")]),r._v(" "),t("p",[t("a",{attrs:{name:"kWAH0"}})]),r._v(" "),t("h2",{attrs:{id:"_20class-的继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20class-的继承"}},[r._v("#")]),r._v(" 20Class 的继承")]),r._v(" "),t("p",[t("a",{attrs:{name:"m4ZEu"}})]),r._v(" "),t("h2",{attrs:{id:"_21module-的语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21module-的语法"}},[r._v("#")]),r._v(" 21Module 的语法")]),r._v(" "),t("p",[t("a",{attrs:{name:"YSkoR"}})]),r._v(" "),t("h2",{attrs:{id:"_22module-的加载实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22module-的加载实现"}},[r._v("#")]),r._v(" 22Module 的加载实现")]),r._v(" "),t("p",[t("a",{attrs:{name:"RjsyR"}})]),r._v(" "),t("h2",{attrs:{id:"_23-编程风格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-编程风格"}},[r._v("#")]),r._v(" 23 编程风格")]),r._v(" "),t("p",[t("a",{attrs:{name:"F3tOw"}})]),r._v(" "),t("h2",{attrs:{id:"_24-读懂规格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-读懂规格"}},[r._v("#")]),r._v(" 24 读懂规格")]),r._v(" "),t("p",[t("a",{attrs:{name:"lGbM3"}})]),r._v(" "),t("h2",{attrs:{id:"_25-异步遍历器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-异步遍历器"}},[r._v("#")]),r._v(" 25 异步遍历器")]),r._v(" "),t("p",[t("a",{attrs:{name:"havWK"}})]),r._v(" "),t("h2",{attrs:{id:"_26-最新提案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-最新提案"}},[r._v("#")]),r._v(" 26 最新提案")]),r._v(" "),t("p",[t("a",{attrs:{name:"Ut1rV"}})]),r._v(" "),t("h2",{attrs:{id:"_27decorator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27decorator"}},[r._v("#")]),r._v(" 27Decorator")])])}),[],!1,null,null,null);t.default=_.exports}}]);